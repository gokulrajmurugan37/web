<div>
  <main class="csv-main">
    <div class="csv-head">
      <h1 class="csv-head-h1" ng-bind="title"></h1>
      <p class="csv-subtitle" ng-bind="subtitle"></p>
    </div>

    <section class="csv-intro-section">
      <h2 class="csv-intro-section-h2">‚öôÔ∏è How It Works</h2>
      <ol class="csv-ol">
        <li class="section-order-list" ng-repeat="step in howItWorksSteps">
          <strong ng-if="step.title">{{ step.title }}</strong><span ng-if="step.title"><br></span>
          <p class="csv-intro-section-description">{{ step.description }}</p>
        </li>
      </ol>
    </section>

    <section ng-repeat="section in guideSections">
      <h2 ng-if="section.heading">{{ section.heading }}</h2>
      <p class="csv-p" ng-if="section.text" ng-bind-html="section.text"></p>
      <ul class="csv-ul" ng-if="section.list">
        <li class="section-order-list" ng-repeat="item in section.list">{{ item }}</li>
      </ul>
      <img ng-if="section.image" ng-src="{{ section.image.src }}" alt="{{ section.image.alt }}" class="csv-image">
      <br>
    </section>



    <section class="feature-section" >
      <div class="section-header">
        <h2>üîé Overview</h2>
      </div>

      <p class="csv-p">{{ overviewDescription }}</p>

      <div class="csv-features-grid">
        <div class="csv-features-card" ng-repeat="feature in features">
          <div class="csv-features-icon"><i class="{{ feature.icon }}"></i></div>
          <h3 class="csv-h3">{{ feature.title }}</h3>
          <p class="csv-p">{{ feature.description }}</p>
        </div>
      </div>
    </section><br><br>
    
    <section class="code-section">
      <div class="code-tabs">
        <button class="csv-tab-button" ng-class="{ 'active': isActiveTab('html-tab') }" ng-click="setActiveTab('html-tab')">HTML</button>
        <button class="csv-tab-button" ng-class="{ 'active': isActiveTab('js-tab') }" ng-click="setActiveTab('js-tab')">JavaScript</button>
        <button class="csv-tab-button" ng-class="{ 'active': isActiveTab('apex-tab') }" ng-click="setActiveTab('apex-tab')">Apex</button>
      </div>

      <div id="html-tab" class="csv-tab-content" ng-class="{ 'active': isActiveTab('html-tab') }">
        <pre class="csv-pre"><code class="csv-code">&lt;template&gt;
    &lt;lightning-card title="Upload CSV to Create Records"&gt;
        &lt;div class="slds-p-around_medium"&gt;
            &lt;lightning-combobox
                label="Select Object"
                value={selectedObject}
                options={objectOptions}
                onchange={handleObjectChange}&gt;
            &lt;/lightning-combobox&gt;

            &lt;lightning-input
                type="file"
                label="Upload CSV"
                accept=".csv"
                onchange={handleFileUpload}&gt;
            &lt;/lightning-input&gt;

            &lt;lightning-button
                label="Upload Records"
                onclick={uploadRecords}
                class="slds-m-top_medium"&gt;
            &lt;/lightning-button&gt;
        &lt;/div&gt;
    &lt;/lightning-card&gt;
&lt;/template&gt;</code></pre>
      </div>

      <div id="js-tab" class="csv-tab-content" ng-class="{ 'active': isActiveTab('js-tab') }">
        <pre class="csv-pre"><code class="csv-code">
import { LightningElement, track } from 'lwc';
import { LightningElement, track } from 'lwc';
import getObjectList from '@salesforce/apex/CSVDataUploadController.getObjectList';
import parseCSVAndCreateRecords from '@salesforce/apex/CSVDataUploadController.parseCSVAndCreateRecords';
import { ShowToastEvent } from 'lightning/platformShowToastEvent';

export default class CsvDataUpload extends LightningElement {
    acceptedFormats = ['.csv'];
    @track objectOptions = [];
    @track selectedObject = '';

    connectedCallback() {
        getObjectList().then(result => {
            this.objectOptions = result.map(obj => {
                const capitalizedLabel = obj.charAt(0).toUpperCase() + obj.slice(1);
                return { label: capitalizedLabel, value: obj };
            });
        });
    }

    handleObjectChange(event) {
        this.selectedObject = event.detail.value;
    }

    handleUploadFinished(event) {
        const uploadedFiles = event.detail.files;
        if (!this.selectedObject || uploadedFiles.length === 0) {
            this.showToast('Error', 'Please select an object and upload a file.', 'error');
            return;
        }

        const documentId = uploadedFiles[0].documentId;
        parseCSVAndCreateRecords({
            contentDocumentId: documentId,
            objectApiName: this.selectedObject
        })
        .then(result => {
            const total = result.totalRecords || 0;
            const success = result.successCount || 0;
            const fail = result.failCount || 0;

            this.showToast(
                'Upload Successful',
                `Total Records: ${total}, Inserted: ${success}, Failed: ${fail}`,
                fail > 0 ? 'warning' : 'success'
            );
        })

        .catch(error => {
            this.showToast('Error ', error.body.message, 'error');
        });
    }

    showToast(title, message, variant) {
        this.dispatchEvent(new ShowToastEvent({ title, message, variant }));
    }
}
</code></pre>
      </div>

      <div id="apex-tab" class="csv-tab-content" ng-class="{ 'active': isActiveTab('apex-tab') }">
        <pre class="csv-pre"><code class="csv-code">
public with sharing class CSVDataUploadController {

    @AuraEnabled(cacheable=true)
    public static List<String> getObjectList() {
        Map<String, Schema.SObjectType> globalDescribe = Schema.getGlobalDescribe();
        List<String> objectNames = new List<String>();

        for (String sObjectName : globalDescribe.keySet()) {
            Schema.DescribeSObjectResult describe = globalDescribe.get(sObjectName).getDescribe();
            if (!shouldSkipObject(sObjectName, describe)) {
                objectNames.add(sObjectName);
            }
        }

        objectNames.sort();
        return objectNames;
    }

    private static Boolean shouldSkipObject(String objName, Schema.DescribeSObjectResult describeResult) {
        return
            objName.toLowerCase().contains('history') ||
            objName.toLowerCase().contains('tag') ||
            objName.toLowerCase().contains('changeevent') ||
            objName.toLowerCase().contains('share') ||
            objName.toLowerCase().contains('feed') ||
            describeResult.isCustomSetting() ||
            describeResult.isDeprecatedAndHidden() ||
            !describeResult.isQueryable() ||
            describeResult.getRecordTypeInfos().isEmpty() ||
            skipObjects().containsKey(objName);
    }

    private static Map<String, Boolean> skipObjects() {
        return new Map<String, Boolean>{
            'Attachment' => true,
            'Note' => true,
            'User' => true,
            'ContentDocumentLink' => true,
            'ContentVersion' => true,
            'FeedItem' => true,
            'EventRelationChangeEvent' => true,
            'ProcessInstance' => true,
            'ProcessInstanceHistory' => true,
            'TaskChangeEvent' => true,
            'EmailMessageChangeEvent' => true,
            'AuthFormRequestRecord' => true,
            'AuthorizationForm' => true,
            'Integration__c' => true,
            'Integration_Transaction__c' => true,
            'Filter__c' => true
        };
    }

    @AuraEnabled
    public static Map<String, Integer> parseCSVAndCreateRecords(Id contentDocumentId, String objectApiName) {
        ContentVersion cv = [
            SELECT VersionData FROM ContentVersion WHERE ContentDocumentId = :contentDocumentId 
            ORDER BY CreatedDate DESC LIMIT 1
        ];

        String csvContent = cv.VersionData.toString();
        List<String> lines = csvContent.split('\n');
        if (lines.isEmpty()) throw new AuraHandledException('CSV file is empty.');

        List<String> rawHeaders = lines[0].replace('\r','').replace('"','').split(',');
        List<String> fieldApiNames = new List<String>();
        for (String header : rawHeaders) {
            fieldApiNames.add(header.trim());
        }

        Schema.SObjectType sObjType = Schema.getGlobalDescribe().get(objectApiName);
        if (sObjType == null) throw new AuraHandledException('Invalid object: ' + objectApiName);

        Map<String, Schema.SObjectField> fieldMap = sObjType.getDescribe().fields.getMap();
        List<String> validFields = new List<String>();
        for (String field : fieldApiNames) {
            if (fieldMap.containsKey(field) && fieldMap.get(field).getDescribe().isCreateable()) {
                validFields.add(field);
            }
        }
        if (validFields.isEmpty()) throw new AuraHandledException('None of the CSV fields are valid/creatable for ' + objectApiName);

        List<SObject> recordsToInsert = new List<SObject>();
        for (Integer i = 1; i < lines.size(); i++) {
            List<String> values = lines[i].replace('\r','').replace('"','').split(',');
            if (values.size() != fieldApiNames.size()) continue;

            SObject record = sObjType.newSObject();
            for (Integer j = 0; j < fieldApiNames.size(); j++) {
                String field = fieldApiNames[j];
                if (validFields.contains(field)) {
                    Schema.DescribeFieldResult fieldDescribe = fieldMap.get(field).getDescribe();
                    String value = values[j].trim();

                    if (String.isNotBlank(value)) {
                        try {
                            switch on fieldDescribe.getType() {
                                when Double, Currency, Percent {
                                    record.put(field, Decimal.valueOf(value));
                                }
                                when Integer {
                                    record.put(field, Integer.valueOf(value));
                                }
                                when Boolean {
                                    record.put(field, Boolean.valueOf(value));
                                }
                                when Date {
                                    record.put(field, Date.valueOf(value));
                                }
                                when DateTime {
                                    record.put(field, Datetime.valueOf(value));
                                }
                                when else {
                                    record.put(field, value);
                                }
                            }
                        } catch (Exception e) {
                            System.debug('Skipping invalid value "' + value + '" for field ' + field + ': ' + e.getMessage());
                        }
                    }
                }
            }
            recordsToInsert.add(record);
        }

        Integer successCount = 0;
        Integer failCount = 0;

        if (!recordsToInsert.isEmpty()) {
            Database.SaveResult[] results = Database.insert(recordsToInsert, false);
            for (Database.SaveResult result : results) {
                if (result.isSuccess()) {
                    successCount++;
                } else {
                    failCount++;
                }
            }
        }
        Map<String, Integer> resultMap = new Map<String, Integer>{
            'totalRecords' => recordsToInsert.size(),
            'successCount' => successCount,
            'failCount' => failCount
        };
        return resultMap;
    }
}
</code></pre>
      </div>


    </section>
    
  </main>
    
</div>